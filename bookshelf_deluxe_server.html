<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manga Bookshelf</title>
    <style>
        :root {
            --category-in-progress: #FF9800;
            --category-planned: #2196F3;
            --category-caught-up: #4CAF50;
            --category-paused: #FF5722;  /* New orange-red color for Paused */
            --category-future: #9C27B0;
            --category-finished: #607D8B;
        }

        /* Mobile-first responsive design */
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 0;
            touch-action: manipulation; /* Prevent accidental zooming */
        }

        .category-section {
            margin-bottom: 1.5rem;
            background: rgba(0,0,0,0.03);
            padding: 0.8rem;
            border-radius: 8px;
        }

        .category-header {
            font-size: 1.3rem;
            margin: 0 0 0.8rem 0;
            padding: 0.5rem;
            color: white;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .category-toggle {
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
        }

        .bookshelf-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.8rem;
        }

        .book {
            position: relative;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            aspect-ratio: 3/4;
        }

        .book-cover {
            width: 100%;
            height: 100%;
        }

        .book-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            pointer-events: none; /* Prevent image drag on mobile */
        }

        .book-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 0.5rem;
            font-size: 0.8rem;
            transform: translateY(100%);
            transition: transform 0.2s;
        }

        .book:hover .book-info,
        .book:focus-within .book-info {
            transform: translateY(0);
        }

        .book-category {
            position: absolute;
            top: 0.3rem;
            right: 0.3rem;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        /* Mobile-specific adjustments */
        @media (max-width: 768px) {
            .bookshelf-container {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 0.6rem;
            }
            
            .book-info {
                font-size: 0.7rem;
                padding: 0.3rem;
                transform: translateY(0);
                opacity: 0.9;
            }
            
            .category-header {
                font-size: 1.1rem;
            }
        }

        /* Category color coding */
        #in-progress-section .category-header { background: var(--category-in-progress); }
        #planned-section .category-header { background: var(--category-planned); }
        #caught-up-section .category-header { background: var(--category-caught-up); }
        #future-section .category-header { background: var(--category-future); }
        #finished-section .category-header { background: var(--category-finished); }
        #paused-section .category-header { background: var(--category-paused); }
    </style>
</head>
<body>
    <div class="category-section" id="in-progress-section">
        <h2 class="category-header">
            <span>In Progress</span>
            <button class="category-toggle">▼</button>
        </h2>
        <div class="bookshelf-container" id="in-progress-books"></div>
    </div>

    <div class="category-section" id="planned-section">
        <h2 class="category-header">
            <span>Planned</span>
            <button class="category-toggle">▼</button>
        </h2>
        <div class="bookshelf-container" id="planned-books"></div>
    </div>

    <div class="category-section" id="caught-up-section">
        <h2 class="category-header">
            <span>Caught Up</span>
            <button class="category-toggle">▼</button>
        </h2>
        <div class="bookshelf-container" id="caught-up-books"></div>
    </div>

    <div class="category-section" id="paused-section">
    <h2 class="category-header">
        <span>Paused</span>
        <button class="category-toggle">▼</button>
    </h2>
    <div class="bookshelf-container" id="paused-books"></div>
    </div>
    
    <div class="category-section" id="future-section">
        <h2 class="category-header">
            <span>Future</span>
            <button class="category-toggle">▼</button>
        </h2>
        <div class="bookshelf-container" id="future-books"></div>
    </div>

    <div class="category-section" id="finished-section">
        <h2 class="category-header">
            <span>Finished</span>
            <button class="category-toggle">▼</button>
        </h2>
        <div class="bookshelf-container" id="finished-books"></div>
    </div>

   <script>
document.addEventListener('DOMContentLoaded', function() {
    // Load data from server
    let categories = {};
    let seriesData = [];
    let lastAccessedVolumes = {};
    
    // Mobile touch prevention
    document.addEventListener('touchmove', function(e) {
        if (e.target.classList.contains('book-cover')) {
            e.preventDefault();
        }
    }, { passive: false });

    // Toggle category sections
    document.querySelectorAll('.category-toggle').forEach(btn => {
        btn.addEventListener('click', function() {
            const section = this.closest('.category-section');
            const container = section.querySelector('.bookshelf-container');
            container.style.display = container.style.display === 'none' ? 'grid' : 'none';
            this.textContent = container.style.display === 'none' ? '▶' : '▼';
        });
    });

    // Load data from server
    async function loadData() {
        try {
            // Load categories
            const catResponse = await fetch('/series_categories');
            if (catResponse.ok) {
                categories = await catResponse.json();
            }
            
            // Load last accessed volumes
            const lastAccessedResponse = await fetch('/last_accessed');
            if (lastAccessedResponse.ok) {
                lastAccessedVolumes = await lastAccessedResponse.json();
            }
            
            // Load progress data
            const progResponse = await fetch('/progress');
            if (progResponse.ok) {
                seriesData = await progResponse.json();
                renderBookshelf();
            }
        } catch (error) {
            console.error('Error loading data:', error);
        }
    }

    // Render the bookshelf
    function renderBookshelf() {
        const uniqueSeries = [...new Set(seriesData.map(item => item.series))];
        const containerMap = {
            'in-progress': document.getElementById('in-progress-books'),
            'planned': document.getElementById('planned-books'),
            'caught-up': document.getElementById('caught-up-books'),
            'paused': document.getElementById('paused-books'),  // New category
            'future': document.getElementById('future-books'),
            'finished': document.getElementById('finished-books')
        };

        // Clear all containers
        Object.values(containerMap).forEach(container => {
            container.innerHTML = '';
        });

        uniqueSeries.forEach(seriesName => {
            const seriesVolumes = seriesData.filter(item => item.series === seriesName);
            
            // Find volumes with progress (page_idx > 0)
            const volumesWithProgress = seriesVolumes.filter(v => v.page_idx > 0);
            
            // Determine which volume to display
            let displayVolume = seriesVolumes[0]; // Default to first volume
            
            // 1. First try to find the volume with the highest page progress
            if (volumesWithProgress.length > 0) {
                // Sort by last_page_idx descending, then by page_idx descending
                volumesWithProgress.sort((a, b) => {
                    if (b.last_page_idx !== a.last_page_idx) {
                        return b.last_page_idx - a.last_page_idx;
                    }
                    return b.page_idx - a.page_idx;
                });
                displayVolume = volumesWithProgress[0];
            }
            // 2. Then check last accessed volumes
            else if (lastAccessedVolumes[seriesName]) {
                const lastAccessed = seriesVolumes.find(v => v.volume === lastAccessedVolumes[seriesName]);
                if (lastAccessed) {
                    displayVolume = lastAccessed;
                }
            }
            
            const category = categories[seriesName] || 'future';
            const container = containerMap[category];
            
            if (container) {
                const bookElement = document.createElement('div');
                bookElement.className = 'book';
                bookElement.innerHTML = `
                    <div class="book-cover">
                        <img src="/manga/${encodeURIComponent(seriesName)}/${encodeURIComponent(displayVolume.volume)}/${encodeURIComponent(displayVolume.cover_page)}" 
                             alt="${seriesName}" loading="lazy">
                        <div class="book-category">${category.replace('-', ' ')}</div>
                    </div>
                    <div class="book-info">
                        <div class="book-title">${seriesName}</div>
                        <select class="category-select" data-series="${seriesName}">
                            <option value="in-progress" ${category === 'in-progress' ? 'selected' : ''}>In Progress</option>
                            <option value="planned" ${category === 'planned' ? 'selected' : ''}>Planned</option>
                            <option value="caught-up" ${category === 'caught-up' ? 'selected' : ''}>Caught Up</option>
                             <option value="paused" ${category === 'paused' ? 'selected' : ''}>Paused</option> 
                            <option value="future" ${category === 'future' ? 'selected' : ''}>Future</option>
                            <option value="finished" ${category === 'finished' ? 'selected' : ''}>Finished</option>
                        </select>
                    </div>
                `;
                
                // Category change handler
                bookElement.querySelector('.category-select').addEventListener('change', async function() {
                    categories[seriesName] = this.value;
                    try {
                        await fetch('/save_category', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                series: seriesName,
                                category: this.value
                            })
                        });
                        renderBookshelf();
                    } catch (error) {
                        console.error('Error saving category:', error);
                    }
                });
                
                // Click handler - update last accessed when opening
                bookElement.addEventListener('click', async function(e) {
                    if (!e.target.closest('.category-select')) {
                        try {
                            await fetch('/update_last_accessed', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    series: seriesName,
                                    volume: displayVolume.volume
                                })
                            });
                            window.location.href = displayVolume.path;
                        } catch (error) {
                            console.error('Error updating last accessed:', error);
                            window.location.href = displayVolume.path;
                        }
                    }
                });
                
                container.appendChild(bookElement);
            }
        });
    }

    loadData();
});
</script>
</body>
</html>
